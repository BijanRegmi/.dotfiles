From 00168b60f2c9930db43dd65dc328ec19a137b782 Mon Sep 17 00:00:00 2001
From: Bijan Regmi <vizandabijan@gmail.com>
Date: Fri, 19 Nov 2021 18:36:05 +0545
Subject: [PATCH] mouse scroll with text redraw after resize

---
 config.def.h |   10 +-
 st.c         | 1015 ++++++++++++++++++++++++++++++++++++--------------
 st.h         |   18 +
 win.h        |    1 +
 x.c          |  109 ++++--
 5 files changed, 845 insertions(+), 308 deletions(-)

diff --git a/config.def.h b/config.def.h
index 6f05dce..80929dc 100644
--- a/config.def.h
+++ b/config.def.h
@@ -176,9 +176,9 @@ static MouseShortcut mshortcuts[] = {
 	/* mask                 button   function        argument       release */
 	{ XK_ANY_MOD,           Button2, selpaste,       {.i = 0},      1 },
 	{ ShiftMask,            Button4, ttysend,        {.s = "\033[5;2~"} },
-	{ XK_ANY_MOD,           Button4, ttysend,        {.s = "\031"} },
+	{ XK_ANY_MOD,           Button4, kscrollup,      {.i = +1} },
 	{ ShiftMask,            Button5, ttysend,        {.s = "\033[6;2~"} },
-	{ XK_ANY_MOD,           Button5, ttysend,        {.s = "\005"} },
+	{ XK_ANY_MOD,           Button5, kscrolldown,    {.i = +1} },
 };
 
 /* Internal keyboard shortcuts. */
@@ -199,6 +199,12 @@ static Shortcut shortcuts[] = {
 	{ TERMMOD,              XK_Y,           selpaste,       {.i =  0} },
 	{ ShiftMask,            XK_Insert,      selpaste,       {.i =  0} },
 	{ TERMMOD,              XK_Num_Lock,    numlock,        {.i =  0} },
+
+	{ ControlMask,          XK_Up,          kscrollup,      {.i = +1} },
+	{ ControlMask,          XK_Down,        kscrolldown,    {.i = +1} },
+	{ ControlMask,          XK_Page_Up,     kscrollup,      {.i = +10}},
+	{ ControlMask,          XK_Page_Down,   kscrolldown,    {.i = +10}},
+
 };
 
 /*
diff --git a/st.c b/st.c
index 76b7e0d..0cfe631 100644
--- a/st.c
+++ b/st.c
@@ -35,6 +35,8 @@
 #define ESC_ARG_SIZ   16
 #define STR_BUF_SIZ   ESC_BUF_SIZ
 #define STR_ARG_SIZ   ESC_ARG_SIZ
+#define HISTSIZE      2000
+#define RESIZEBUFFER  1000
 
 /* macros */
 #define IS_SET(flag)		((term.mode & (flag)) != 0)
@@ -42,6 +44,25 @@
 #define ISCONTROLC1(c)		(BETWEEN(c, 0x80, 0x9f))
 #define ISCONTROL(c)		(ISCONTROLC0(c) || ISCONTROLC1(c))
 #define ISDELIM(u)		(u && wcschr(worddelimiters, u))
+#define ISSPACE(gp)		(gp->u == ' ' && gp->state == GLYPH_SET)
+#define STRESCARGREST(n)	((n) == 0 ? strescseq.buf : strescseq.argp[(n)-1] + 1)
+#define STRESCARGJUST(n)	(*(strescseq.argp[n]) = '\0', STRESCARGREST(n))
+
+#define TLINE(y) ( \
+	(y) < term.scr ? term.hist[(term.histi + (y) - term.scr + 1 + HISTSIZE) % HISTSIZE] \
+	               : term.line[(y) - term.scr] \
+)
+
+#define TLINEABS(y) ( \
+	(y) < 0 ? term.hist[(term.histi + (y) + 1 + HISTSIZE) % HISTSIZE] : term.line[(y)] \
+)
+
+#define UPDATEWRAPNEXT(alt, col) do { \
+	if ((term.c.state & CURSOR_WRAPNEXT) && term.c.x + term.wrapcwidth[alt] < col) { \
+		term.c.x += term.wrapcwidth[alt]; \
+		term.c.state &= ~CURSOR_WRAPNEXT; \
+	} \
+} while (0);
 
 enum term_mode {
 	MODE_WRAP        = 1 << 0,
@@ -53,6 +74,13 @@ enum term_mode {
 	MODE_UTF8        = 1 << 6,
 };
 
+enum scroll_mode {
+	SCROLL_RESIZE = -1,
+	SCROLL_NOSAVEHIST = 0,
+	SCROLL_SAVEHIST = 1
+};
+
+
 enum cursor_movement {
 	CURSOR_SAVE,
 	CURSOR_LOAD
@@ -128,6 +156,11 @@ typedef struct {
 	int icharset; /* selected charset for sequence */
 	int *tabs;
 	Rune lastc;   /* last printed char outside of sequence, 0 if control */
+	int wrapcwidth[2];   /* used in updating WRAPNEXT when resizing */
+	Line hist[HISTSIZE]; /* history buffer */
+	int histi;           /* history index */
+	int histf;           /* nb history available */
+	int scr;             /* scroll back */
 } Term;
 
 /* CSI Escape sequence structs */
@@ -148,7 +181,7 @@ typedef struct {
 	char *buf;             /* allocated raw string */
 	size_t siz;            /* allocation size */
 	size_t len;            /* raw string length */
-	char *args[STR_ARG_SIZ];
+	char *argp[STR_ARG_SIZ]; /* pointers to the end of nth argument */
 	int narg;              /* nb of args */
 } STREscape;
 
@@ -171,40 +204,53 @@ static void tprinter(char *, size_t);
 static void tdumpsel(void);
 static void tdumpline(int);
 static void tdump(void);
-static void tclearregion(int, int, int, int);
-static void tcursor(int);
+static void tclearglyph(Glyph *, int);
+static void tclearregion(int, int, int, int, int);
+static void tresetcursor(void);
 static void tdeletechar(int);
 static void tdeleteline(int);
 static void tinsertblank(int);
 static void tinsertblankline(int);
-static int tlinelen(int);
+static int tlinelen(Line line);
+static int tiswrapped(Line line);
+static char *tgetline(char *, const Glyph *, const Glyph *, int);
 static void tmoveto(int, int);
 static void tmoveato(int, int);
 static void tnewline(int);
 static void tputtab(int);
+static void twritetab(void);
 static void tputc(Rune);
 static void treset(void);
-static void tscrollup(int, int);
+static void tscrollup(int, int, int, int);
 static void tscrolldown(int, int);
-static void tsetattr(int *, int);
-static void tsetchar(Rune, Glyph *, int, int);
+static void treflow(int, int);
+static void rscrolldown(int);
+static void tresizedef(int, int);
+static void tresizealt(int, int);
+static void tsetattr(const int *, int);
+static void tsetchar(Rune, const Glyph *, int, int);
 static void tsetdirt(int, int);
 static void tsetscroll(int, int);
 static void tswapscreen(void);
-static void tsetmode(int, int, int *, int);
+static void tloaddefscreen(int, int);
+static void tloadaltscreen(int, int);
+static void tsetmode(int, int, const int *, int);
 static int twrite(const char *, int, int);
 static void tfulldirt(void);
-static void tcontrolcode(uchar );
-static void tdectest(char );
+static void tcontrolcode(uchar);
+static void tdectest(char);
 static void tdefutf8(char);
-static int32_t tdefcolor(int *, int *, int);
+static int32_t tdefcolor(const int *, int *, int);
 static void tdeftran(char);
 static void tstrsequence(uchar);
 
 static void drawregion(int, int, int, int);
 
 static void selnormalize(void);
-static void selscroll(int, int);
+static void selmove(int);
+static void selremove(void);
+static void selscroll(int, int, int);
+static int regionselected(int, int, int, int);
 static void selsnap(int *, int *, int);
 
 static size_t utf8decode(const char *, Rune *, size_t);
@@ -410,19 +456,38 @@ selinit(void)
 }
 
 int
-tlinelen(int y)
+tlinelen(Line line)
 {
-	int i = term.col;
+	int i = term.col - 1;
 
-	if (term.line[y][i - 1].mode & ATTR_WRAP)
-		return i;
+	for (; i >= 0 && line[i].state == GLYPH_EMPTY; i--);
+	return i + 1;
+}
 
-	while (i > 0 && term.line[y][i - 1].u == ' ')
-		--i;
+int
+tiswrapped(Line line)
+{
+	int len = tlinelen(line);
 
-	return i;
+	return len > 0 && (line[len - 1].mode & ATTR_WRAP);
 }
 
+char *
+tgetline(char *buf, const Glyph *gp, const Glyph *last, int gettab)
+{
+	while (gp <= last)
+		if (gp->mode & ATTR_WDUMMY) {
+			gp++;
+		} else if (gettab && gp->state == GLYPH_TAB) {
+			*(buf++) = '\t';
+			while (++gp <= last && gp->state == GLYPH_TDUMMY);
+		} else {
+			buf += utf8encode((gp++)->u, buf);
+		}
+	return buf;
+}
+
+
 void
 selstart(int col, int row, int snap)
 {
@@ -460,11 +525,13 @@ selextend(int col, int row, int type, int done)
 
 	sel.oe.x = col;
 	sel.oe.y = row;
-	selnormalize();
 	sel.type = type;
+	selnormalize();
 
-	if (oldey != sel.oe.y || oldex != sel.oe.x || oldtype != sel.type || sel.mode == SEL_EMPTY)
+	if (oldey != sel.oe.y || oldex != sel.oe.x ||
+	    oldtype != sel.type || sel.mode == SEL_EMPTY) {
 		tsetdirt(MIN(sel.nb.y, oldsby), MAX(sel.ne.y, oldsey));
+  }
 
 	sel.mode = done ? SEL_IDLE : SEL_READY;
 }
@@ -473,6 +540,7 @@ void
 selnormalize(void)
 {
 	int i;
+	Line line;
 
 	if (sel.type == SEL_REGULAR && sel.ob.y != sel.oe.y) {
 		sel.nb.x = sel.ob.y < sel.oe.y ? sel.ob.x : sel.oe.x;
@@ -487,38 +555,57 @@ selnormalize(void)
 	selsnap(&sel.nb.x, &sel.nb.y, -1);
 	selsnap(&sel.ne.x, &sel.ne.y, +1);
 
-	/* expand selection over line breaks */
 	if (sel.type == SEL_RECTANGULAR)
 		return;
-	i = tlinelen(sel.nb.y);
-	if (i < sel.nb.x)
+
+	/* expand selection over line breaks and tabs */
+	line = TLINE(sel.nb.y);
+	i = tlinelen(line);
+	if (sel.nb.x > i)
 		sel.nb.x = i;
-	if (tlinelen(sel.ne.y) <= sel.ne.x)
+	while (sel.nb.x > 0 && line[sel.nb.x].state == GLYPH_TDUMMY)
+		if (line[sel.nb.x-1].state >= GLYPH_TAB)
+			sel.nb.x--;
+
+	line = TLINE(sel.ne.y);
+	i = tlinelen(line) - 1;
+	if (sel.ne.x > i) {
 		sel.ne.x = term.col - 1;
+		return;
+	}
+	if (line[sel.ne.x].state >= GLYPH_TAB)
+		while (sel.ne.x < i && line[sel.ne.x+1].state == GLYPH_TDUMMY)
+			sel.ne.x++;
 }
 
 int
-selected(int x, int y)
+regionselected(int x1, int y1, int x2, int y2)
 {
-	if (sel.mode == SEL_EMPTY || sel.ob.x == -1 ||
-			sel.alt != IS_SET(MODE_ALTSCREEN))
+	if (sel.ob.x == -1 || sel.mode == SEL_EMPTY ||
+	    sel.alt != IS_SET(MODE_ALTSCREEN) || sel.nb.y > y2 || sel.ne.y < y1)
 		return 0;
 
-	if (sel.type == SEL_RECTANGULAR)
-		return BETWEEN(y, sel.nb.y, sel.ne.y)
-		    && BETWEEN(x, sel.nb.x, sel.ne.x);
+	return (sel.type == SEL_RECTANGULAR) ? sel.nb.x <= x2 && sel.ne.x >= x1
+		: (sel.nb.y != y2 || sel.nb.x <= x2) &&
+		  (sel.ne.y != y1 || sel.ne.x >= x1);
+}
 
-	return BETWEEN(y, sel.nb.y, sel.ne.y)
-	    && (y != sel.nb.y || x >= sel.nb.x)
-	    && (y != sel.ne.y || x <= sel.ne.x);
+int
+selected(int x, int y)
+{
+	return regionselected(x, y, x, y);
 }
 
 void
 selsnap(int *x, int *y, int direction)
 {
 	int newx, newy, xt, yt;
+	int rtop = 0, rbot = term.row - 1;
 	int delim, prevdelim;
-	Glyph *gp, *prevgp;
+	const Glyph *gp, *prevgp;
+
+	if (!IS_SET(MODE_ALTSCREEN))
+		rtop += -term.histf + term.scr, rbot += term.scr;
 
 	switch (sel.snap) {
 	case SNAP_WORD:
@@ -526,7 +613,7 @@ selsnap(int *x, int *y, int direction)
 		 * Snap around if the word wraps around at the end or
 		 * beginning of a line.
 		 */
-		prevgp = &term.line[*y][*x];
+		prevgp = &TLINE(*y)[*x];
 		prevdelim = ISDELIM(prevgp->u);
 		for (;;) {
 			newx = *x + direction;
@@ -534,24 +621,24 @@ selsnap(int *x, int *y, int direction)
 			if (!BETWEEN(newx, 0, term.col - 1)) {
 				newy += direction;
 				newx = (newx + term.col) % term.col;
-				if (!BETWEEN(newy, 0, term.row - 1))
+				if (!BETWEEN(newy, rtop, rbot))
 					break;
 
 				if (direction > 0)
 					yt = *y, xt = *x;
 				else
 					yt = newy, xt = newx;
-				if (!(term.line[yt][xt].mode & ATTR_WRAP))
+				if (!(TLINE(yt)[xt].mode & ATTR_WRAP))
 					break;
 			}
 
-			if (newx >= tlinelen(newy))
+			if (newx >= tlinelen(TLINE(newy)))
 				break;
 
-			gp = &term.line[newy][newx];
+			gp = &TLINE(newy)[newx];
 			delim = ISDELIM(gp->u);
-			if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim
-					|| (delim && gp->u != prevgp->u)))
+			if (!(gp->mode & ATTR_WDUMMY) && (delim != prevdelim ||
+			    (delim && !(ISSPACE(gp) && ISSPACE(prevgp)))))
 				break;
 
 			*x = newx;
@@ -568,18 +655,14 @@ selsnap(int *x, int *y, int direction)
 		 */
 		*x = (direction < 0) ? 0 : term.col - 1;
 		if (direction < 0) {
-			for (; *y > 0; *y += direction) {
-				if (!(term.line[*y-1][term.col-1].mode
-						& ATTR_WRAP)) {
+			for (; *y > rtop; *y -= 1) {
+				if (!tiswrapped(TLINE(*y-1)))
 					break;
-				}
 			}
 		} else if (direction > 0) {
-			for (; *y < term.row-1; *y += direction) {
-				if (!(term.line[*y][term.col-1].mode
-						& ATTR_WRAP)) {
+			for (; *y < rbot; *y += 1) {
+				if (!tiswrapped(TLINE(*y)))
 					break;
-				}
 			}
 		}
 		break;
@@ -590,40 +673,34 @@ char *
 getsel(void)
 {
 	char *str, *ptr;
-	int y, bufsize, lastx, linelen;
-	Glyph *gp, *last;
+	int y, lastx, linelen;
+	const Glyph *gp, *last;
 
-	if (sel.ob.x == -1)
+	if (sel.ob.x == -1 || sel.alt != IS_SET(MODE_ALTSCREEN))
 		return NULL;
 
-	bufsize = (term.col+1) * (sel.ne.y-sel.nb.y+1) * UTF_SIZ;
-	ptr = str = xmalloc(bufsize);
+	str = xmalloc((term.col + 1) * (sel.ne.y - sel.nb.y + 1) * UTF_SIZ);
+	ptr = str;
 
 	/* append every set & selected glyph to the selection */
 	for (y = sel.nb.y; y <= sel.ne.y; y++) {
-		if ((linelen = tlinelen(y)) == 0) {
+		Line line = TLINE(y);
+
+		if ((linelen = tlinelen(line)) == 0) {
 			*ptr++ = '\n';
 			continue;
 		}
 
 		if (sel.type == SEL_RECTANGULAR) {
-			gp = &term.line[y][sel.nb.x];
+			gp = &line[sel.nb.x];
 			lastx = sel.ne.x;
 		} else {
-			gp = &term.line[y][sel.nb.y == y ? sel.nb.x : 0];
+			gp = &line[sel.nb.y == y ? sel.nb.x : 0];
 			lastx = (sel.ne.y == y) ? sel.ne.x : term.col-1;
 		}
-		last = &term.line[y][MIN(lastx, linelen-1)];
-		while (last >= gp && last->u == ' ')
-			--last;
-
-		for ( ; gp <= last; ++gp) {
-			if (gp->mode & ATTR_WDUMMY)
-				continue;
-
-			ptr += utf8encode(gp->u, ptr);
-		}
+		last = &line[MIN(lastx, linelen-1)];
 
+		ptr = tgetline(ptr, gp, last, sel.type != SEL_RECTANGULAR);
 		/*
 		 * Copy and pasting of line endings is inconsistent
 		 * in the inconsistent terminal and GUI world.
@@ -637,7 +714,7 @@ getsel(void)
 		    (!(last->mode & ATTR_WRAP) || sel.type == SEL_RECTANGULAR))
 			*ptr++ = '\n';
 	}
-	*ptr = 0;
+	*ptr = '\0';
 	return str;
 }
 
@@ -646,9 +723,15 @@ selclear(void)
 {
 	if (sel.ob.x == -1)
 		return;
+	selremove();
+	tsetdirt(sel.nb.y, sel.ne.y);
+}
+
+void
+selremove(void)
+{
 	sel.mode = SEL_IDLE;
 	sel.ob.x = -1;
-	tsetdirt(sel.nb.y, sel.ne.y);
 }
 
 void
@@ -849,6 +932,7 @@ ttywrite(const char *s, size_t n, int may_echo)
 {
 	const char *next;
 
+	kscrolldown(&((Arg){ .i = term.scr }));
 	if (may_echo && IS_SET(MODE_ECHO))
 		twrite(s, n, 1);
 
@@ -984,7 +1068,7 @@ tsetdirtattr(int attr)
 	for (i = 0; i < term.row-1; i++) {
 		for (j = 0; j < term.col-1; j++) {
 			if (term.line[i][j].mode & attr) {
-				tsetdirt(i, i);
+				term.dirty[i] = 1;
 				break;
 			}
 		}
@@ -994,7 +1078,7 @@ tsetdirtattr(int attr)
 void
 tfulldirt(void)
 {
-	tsetdirt(0, term.row-1);
+	memset(term.dirty, 1, term.row * sizeof(*term.dirty));
 }
 
 void
@@ -1011,30 +1095,33 @@ tcursor(int mode)
 	}
 }
 
+void
+tresetcursor(void)
+{
+	term.c = (TCursor){ { .mode = ATTR_NULL, .fg = defaultfg, .bg = defaultbg },
+	                    .x = 0, .y = 0, .state = CURSOR_DEFAULT };
+}
+
 void
 treset(void)
 {
 	uint i;
 
-	term.c = (TCursor){{
-		.mode = ATTR_NULL,
-		.fg = defaultfg,
-		.bg = defaultbg
-	}, .x = 0, .y = 0, .state = CURSOR_DEFAULT};
-
+	tresetcursor();
 	memset(term.tabs, 0, term.col * sizeof(*term.tabs));
 	for (i = tabspaces; i < term.col; i += tabspaces)
 		term.tabs[i] = 1;
 	term.top = 0;
 	term.bot = term.row - 1;
+	term.histf = 0;
+	term.scr = 0;
 	term.mode = MODE_WRAP|MODE_UTF8;
 	memset(term.trantbl, CS_USA, sizeof(term.trantbl));
 	term.charset = 0;
 
 	for (i = 0; i < 2; i++) {
-		tmoveto(0, 0);
 		tcursor(CURSOR_SAVE);
-		tclearregion(0, 0, term.col-1, term.row-1);
+		tclearregion(0, 0, term.col-1, term.row-1, 0);
 		tswapscreen();
 	}
 }
@@ -1042,93 +1129,233 @@ treset(void)
 void
 tnew(int col, int row)
 {
-	term = (Term){ .c = { .attr = { .fg = defaultfg, .bg = defaultbg } } };
-	tresize(col, row);
+	int i, j;
+
+	for (i = 0; i < 2; i++) {
+		term.line = xmalloc(row * sizeof(Line));
+		for (j = 0; j < row; j++)
+			term.line[j] = xmalloc(col * sizeof(Glyph));
+		term.col = col, term.row = row;
+		tswapscreen();
+	}
+	term.dirty = xmalloc(row * sizeof(*term.dirty));
+	term.tabs = xmalloc(col * sizeof(*term.tabs));
+	for (i = 0; i < HISTSIZE; i++)
+		term.hist[i] = xmalloc(col * sizeof(Glyph));
 	treset();
 }
 
 void
 tswapscreen(void)
 {
-	Line *tmp = term.line;
+	static Line *altline;
+	Line *tmpline = term.line;
+	static int altcol, altrow;
+	int tmpcol = term.col, tmprow = term.row;
 
-	term.line = term.alt;
-	term.alt = tmp;
+	term.line = altline;
+	term.col = altcol, term.row = altrow;
+	altline = tmpline;
+	altcol = tmpcol, altrow = tmprow;
 	term.mode ^= MODE_ALTSCREEN;
+}
+
+
+void
+tloaddefscreen(int clear, int loadcursor)
+{
+	int col, row, alt = IS_SET(MODE_ALTSCREEN);
+
+	if (alt) {
+		if (clear)
+			tclearregion(0, 0, term.col-1, term.row-1, 1);
+		col = term.col, row = term.row;
+		tswapscreen();
+	}
+	if (loadcursor)
+		tcursor(CURSOR_LOAD);
+	if (alt)
+		tresizedef(col, row);
+}
+
+void
+tloadaltscreen(int clear, int savecursor)
+{
+	int col, row, def = !IS_SET(MODE_ALTSCREEN);
+
+	if (savecursor)
+		tcursor(CURSOR_SAVE);
+	if (def) {
+		col = term.col, row = term.row;
+		tswapscreen();
+		term.scr = 0;
+		tresizealt(col, row);
+	}
+	if (clear)
+		tclearregion(0, 0, term.col-1, term.row-1, 1);
+}
+
+int
+tisaltscreen(void)
+{
+	return IS_SET(MODE_ALTSCREEN);
+}
+
+void
+kscrolldown(const Arg* a)
+{
+	int n = a->i;
+
+	if (!term.scr || IS_SET(MODE_ALTSCREEN))
+		return;
+
+	if (n < 0)
+		n = MAX(term.row / -n, 1);
+
+	if (n <= term.scr) {
+		term.scr -= n;
+	} else {
+		n = term.scr;
+		term.scr = 0;
+	}
+
+	if (sel.ob.x != -1 && !sel.alt)
+		selmove(-n); /* negate change in term.scr */
 	tfulldirt();
 }
 
 void
-tscrolldown(int orig, int n)
+kscrollup(const Arg* a)
 {
-	int i;
+	int n = a->i;
+
+	if (!term.histf || IS_SET(MODE_ALTSCREEN))
+		return;
+
+	if (n < 0)
+		n = MAX(term.row / -n, 1);
+
+	if (term.scr + n <= term.histf) {
+		term.scr += n;
+	} else {
+		n = term.histf - term.scr;
+		term.scr = term.histf;
+	}
+
+	if (sel.ob.x != -1 && !sel.alt)
+		selmove(n); /* negate change in term.scr */
+	tfulldirt();
+}
+
+void
+tscrolldown(int top, int n)
+{
+	int i, bot = term.bot;
 	Line temp;
 
-	LIMIT(n, 0, term.bot-orig+1);
+	if (n <= 0)
+		return;
+	n = MIN(n, bot-top+1);
 
-	tsetdirt(orig, term.bot-n);
-	tclearregion(0, term.bot-n+1, term.col-1, term.bot);
+	tsetdirt(top, bot-n);
+	tclearregion(0, bot-n+1, term.col-1, bot, 1);
 
-	for (i = term.bot; i >= orig+n; i--) {
+	for (i = bot; i >= top+n; i--) {
 		temp = term.line[i];
 		term.line[i] = term.line[i-n];
 		term.line[i-n] = temp;
 	}
 
-	selscroll(orig, n);
+	if (sel.ob.x != -1 && sel.alt == IS_SET(MODE_ALTSCREEN))
+		selscroll(top, bot, n);
 }
 
 void
-tscrollup(int orig, int n)
+tscrollup(int top, int bot, int n, int mode)
 {
-	int i;
+	int i, j, s;
+	int alt = IS_SET(MODE_ALTSCREEN);
+	int savehist = !alt && top == 0 && mode != SCROLL_NOSAVEHIST;
 	Line temp;
 
-	LIMIT(n, 0, term.bot-orig+1);
+	if (n <= 0)
+		return;
+	n = MIN(n, bot-top+1);
+
+	if (savehist) {
+		for (i = 0; i < n; i++) {
+			term.histi = (term.histi + 1) % HISTSIZE;
+			temp = term.hist[term.histi];
+			for (j = 0; j < term.col; j++)
+				tclearglyph(&temp[j], 1);
+			term.hist[term.histi] = term.line[i];
+			term.line[i] = temp;
+		}
+		term.histf = MIN(term.histf + n, HISTSIZE);
+		s = n;
+		if (term.scr) {
+			j = term.scr;
+			term.scr = MIN(j + n, HISTSIZE);
+			s = j + n - term.scr;
+		}
+		if (mode != SCROLL_RESIZE)
+			tfulldirt();
+	} else {
+		tclearregion(0, top, term.col-1, top+n-1, 1);
+		tsetdirt(top+n, bot);
+	}
 
-	tclearregion(0, orig, term.col-1, orig+n-1);
-	tsetdirt(orig+n, term.bot);
 
-	for (i = orig; i <= term.bot-n; i++) {
+	for (i = top; i <= bot-n; i++) {
 		temp = term.line[i];
 		term.line[i] = term.line[i+n];
 		term.line[i+n] = temp;
 	}
 
-	selscroll(orig, -n);
+	if (sel.ob.x != -1 && sel.alt == alt) {
+		if (!savehist) {
+			selscroll(top, bot, -n);
+		} else if (s > 0) {
+			selmove(-s);
+			if (-term.scr + sel.nb.y < -term.histf)
+				selremove();
+		}
+	}
 }
 
 void
-selscroll(int orig, int n)
+selmove(int n)
 {
-	if (sel.ob.x == -1)
-		return;
+	sel.ob.y += n, sel.nb.y += n;
+	sel.oe.y += n, sel.ne.y += n;
+}
+
+void
+selscroll(int top, int bot, int n)
+{
+	/* turn absolute coordinates into relative */
+	top += term.scr, bot += term.scr;
 
-	if (BETWEEN(sel.nb.y, orig, term.bot) != BETWEEN(sel.ne.y, orig, term.bot)) {
+	if (BETWEEN(sel.nb.y, top, bot) != BETWEEN(sel.ne.y, top, bot)) {
 		selclear();
-	} else if (BETWEEN(sel.nb.y, orig, term.bot)) {
-		sel.ob.y += n;
-		sel.oe.y += n;
-		if (sel.ob.y < term.top || sel.ob.y > term.bot ||
-		    sel.oe.y < term.top || sel.oe.y > term.bot) {
+	} else if (BETWEEN(sel.nb.y, top, bot)) {
+		selmove(n);
+		if (sel.nb.y < top || sel.ne.y > bot)
 			selclear();
-		} else {
-			selnormalize();
-		}
 	}
 }
 
 void
-tnewline(int first_col)
+tnewline(int firstcol)
 {
 	int y = term.c.y;
 
 	if (y == term.bot) {
-		tscrollup(term.top, 1);
+		tscrollup(term.top, term.bot, 1, SCROLL_SAVEHIST);
 	} else {
 		y++;
 	}
-	tmoveto(first_col ? 0 : term.c.x, y);
+	tmoveto(firstcol ? 0 : term.c.x, y);
 }
 
 void
@@ -1186,9 +1413,9 @@ tmoveto(int x, int y)
 }
 
 void
-tsetchar(Rune u, Glyph *attr, int x, int y)
+tsetchar(Rune u, const Glyph *attr, int x, int y)
 {
-	static char *vt100_0[62] = { /* 0x41 - 0x7e */
+	static const char *vt100_0[62] = { /* 0x41 - 0x7e */
 		"↑", "↓", "→", "←", "█", "▚", "☃", /* A - G */
 		0, 0, 0, 0, 0, 0, 0, 0, /* H - O */
 		0, 0, 0, 0, 0, 0, 0, 0, /* P - W */
@@ -1219,70 +1446,76 @@ tsetchar(Rune u, Glyph *attr, int x, int y)
 	term.dirty[y] = 1;
 	term.line[y][x] = *attr;
 	term.line[y][x].u = u;
+	term.line[y][x].state = GLYPH_SET;
+
 }
 
 void
-tclearregion(int x1, int y1, int x2, int y2)
+tclearglyph(Glyph *gp, int usecurattr)
 {
-	int x, y, temp;
-	Glyph *gp;
+	if (usecurattr) {
+		gp->fg = term.c.attr.fg;
+		gp->bg = term.c.attr.bg;
+	} else {
+		gp->fg = defaultfg;
+		gp->bg = defaultbg;
+	}
+	gp->mode = ATTR_NULL;
+	gp->state = GLYPH_EMPTY;
+	gp->u = ' ';
+}
 
-	if (x1 > x2)
-		temp = x1, x1 = x2, x2 = temp;
-	if (y1 > y2)
-		temp = y1, y1 = y2, y2 = temp;
+void
+tclearregion(int x1, int y1, int x2, int y2, int usecurattr)
+{
+	int x, y;
 
-	LIMIT(x1, 0, term.col-1);
-	LIMIT(x2, 0, term.col-1);
-	LIMIT(y1, 0, term.row-1);
-	LIMIT(y2, 0, term.row-1);
+	/* regionselected() takes relative coordinates */
+	if (regionselected(x1+term.scr, y1+term.scr, x2+term.scr, y2+term.scr))
+		selremove();
 
 	for (y = y1; y <= y2; y++) {
 		term.dirty[y] = 1;
-		for (x = x1; x <= x2; x++) {
-			gp = &term.line[y][x];
-			if (selected(x, y))
-				selclear();
-			gp->fg = term.c.attr.fg;
-			gp->bg = term.c.attr.bg;
-			gp->mode = 0;
-			gp->u = ' ';
-		}
+		for (x = x1; x <= x2; x++)
+			tclearglyph(&term.line[y][x], usecurattr);
 	}
 }
 
 void
 tdeletechar(int n)
 {
-	int dst, src, size;
-	Glyph *line;
-
-	LIMIT(n, 0, term.col - term.c.x);
+	int src, dst, size;
+	Line line;
 
+	if (n <= 0)
+		return;
 	dst = term.c.x;
-	src = term.c.x + n;
+	src = MIN(term.c.x + n, term.col);
 	size = term.col - src;
-	line = term.line[term.c.y];
-
-	memmove(&line[dst], &line[src], size * sizeof(Glyph));
-	tclearregion(term.col-n, term.c.y, term.col-1, term.c.y);
+	if (size > 0) { /* otherwise src would point beyond the array
+	                   https://stackoverflow.com/questions/29844298 */
+		line = term.line[term.c.y];
+		memmove(&line[dst], &line[src], size * sizeof(Glyph));
+	}
+	tclearregion(dst + size, term.c.y, term.col - 1, term.c.y, 1);
 }
 
 void
 tinsertblank(int n)
 {
-	int dst, src, size;
-	Glyph *line;
-
-	LIMIT(n, 0, term.col - term.c.x);
+	int src, dst, size;
+	Line line;
 
-	dst = term.c.x + n;
+	if (n <= 0)
+		return;
+	dst = MIN(term.c.x + n, term.col);
 	src = term.c.x;
 	size = term.col - dst;
-	line = term.line[term.c.y];
-
-	memmove(&line[dst], &line[src], size * sizeof(Glyph));
-	tclearregion(src, term.c.y, dst - 1, term.c.y);
+	if (size > 0) { /* otherwise dst would point beyond the array */
+		line = term.line[term.c.y];
+		memmove(&line[dst], &line[src], size * sizeof(Glyph));
+	}
+	tclearregion(src, term.c.y, dst - 1, term.c.y, 1);
 }
 
 void
@@ -1296,11 +1529,11 @@ void
 tdeleteline(int n)
 {
 	if (BETWEEN(term.c.y, term.top, term.bot))
-		tscrollup(term.c.y, n);
+		tscrollup(term.c.y, term.bot, n, SCROLL_NOSAVEHIST);
 }
 
 int32_t
-tdefcolor(int *attr, int *npar, int l)
+tdefcolor(const int *attr, int *npar, int l)
 {
 	int32_t idx = -1;
 	uint r, g, b;
@@ -1350,7 +1583,7 @@ tdefcolor(int *attr, int *npar, int l)
 }
 
 void
-tsetattr(int *attr, int l)
+tsetattr(const int *attr, int l)
 {
 	int i;
 	int32_t idx;
@@ -1468,9 +1701,9 @@ tsetscroll(int t, int b)
 }
 
 void
-tsetmode(int priv, int set, int *args, int narg)
+tsetmode(int priv, int set, const int *args, int narg)
 {
-	int alt, *lim;
+	const int *lim;
 
 	for (lim = args + narg; args < lim; ++args) {
 		if (priv) {
@@ -1530,27 +1763,22 @@ tsetmode(int priv, int set, int *args, int narg)
 			case 1034:
 				xsetmode(set, MODE_8BIT);
 				break;
-			case 1049: /* swap screen & set/restore cursor as xterm */
+			case 1049: /* swap screen + save/restore cursor, clearing
+			              alternate screen when switching to it */
+			case 1047: /* swap screen, clearing alternate screen
+			              when switching from it */
+			case 47:   /* swap screen */
 				if (!allowaltscreen)
 					break;
-				tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
-				/* FALLTHROUGH */
-			case 47: /* swap screen */
-			case 1047:
-				if (!allowaltscreen)
-					break;
-				alt = IS_SET(MODE_ALTSCREEN);
-				if (alt) {
-					tclearregion(0, 0, term.col-1,
-							term.row-1);
-				}
-				if (set ^ alt) /* set is always 1 or 0 */
-					tswapscreen();
-				if (*args != 1049)
-					break;
-				/* FALLTHROUGH */
+				if (set)
+					tloadaltscreen(*args == 1049, *args == 1049);
+				else
+					tloaddefscreen(*args == 1047, *args == 1049);
+				break;
 			case 1048:
-				tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
+				if (!allowaltscreen)
+          break;
+  			tcursor((set) ? CURSOR_SAVE : CURSOR_LOAD);
 				break;
 			case 2004: /* 2004: bracketed paste mode */
 				xsetmode(set, MODE_BRCKTPASTE);
@@ -1601,7 +1829,7 @@ void
 csihandle(void)
 {
 	char buf[40];
-	int len;
+	int n, x;
 
 	switch (csiescseq.mode[0]) {
 	default:
@@ -1699,20 +1927,30 @@ csihandle(void)
 	case 'J': /* ED -- Clear screen */
 		switch (csiescseq.arg[0]) {
 		case 0: /* below */
-			tclearregion(term.c.x, term.c.y, term.col-1, term.c.y);
+			tclearregion(term.c.x, term.c.y, term.col-1, term.c.y, 1);
 			if (term.c.y < term.row-1) {
-				tclearregion(0, term.c.y+1, term.col-1,
-						term.row-1);
+				tclearregion(0, term.c.y+1, term.col-1, term.row-1, 1);
 			}
 			break;
 		case 1: /* above */
-			if (term.c.y > 1)
-				tclearregion(0, 0, term.col-1, term.c.y-1);
-			tclearregion(0, term.c.y, term.c.x, term.c.y);
+			if (term.c.y >= 1)
+				tclearregion(0, 0, term.col-1, term.c.y-1, 1);
+			tclearregion(0, term.c.y, term.c.x, term.c.y, 1);
 			break;
 		case 2: /* all */
-			tclearregion(0, 0, term.col-1, term.row-1);
-			break;
+			if (IS_SET(MODE_ALTSCREEN)) {
+  			tclearregion(0, 0, term.col-1, term.row-1, 1);
+  			break;
+      }
+			/* vte does this:
+			tscrollup(0, term.row-1, term.row, SCROLL_SAVEHIST); */
+      
+			/* alacritty does this: */
+			for (n = term.row-1; n >= 0 && tlinelen(term.line[n]) == 0; n--);
+			if (n >= 0)
+				tscrollup(0, term.row-1, n+1, SCROLL_SAVEHIST);
+			tscrollup(0, term.row-1, term.row-n-1, SCROLL_NOSAVEHIST);
+      break;
 		default:
 			goto unknown;
 		}
@@ -1720,20 +1958,20 @@ csihandle(void)
 	case 'K': /* EL -- Clear line */
 		switch (csiescseq.arg[0]) {
 		case 0: /* right */
-			tclearregion(term.c.x, term.c.y, term.col-1,
-					term.c.y);
+			tclearregion(term.c.x, term.c.y, term.col-1, term.c.y, 1);
 			break;
 		case 1: /* left */
-			tclearregion(0, term.c.y, term.c.x, term.c.y);
+			tclearregion(0, term.c.y, term.c.x, term.c.y, 1);
 			break;
 		case 2: /* all */
-			tclearregion(0, term.c.y, term.col-1, term.c.y);
+			tclearregion(0, term.c.y, term.col-1, term.c.y, 1);
 			break;
 		}
 		break;
 	case 'S': /* SU -- Scroll <n> line up */
 		DEFAULT(csiescseq.arg[0], 1);
-		tscrollup(term.top, csiescseq.arg[0]);
+		/* xterm, urxvt, alacritty save this in history */
+		tscrollup(term.top, term.bot, csiescseq.arg[0], SCROLL_SAVEHIST);
 		break;
 	case 'T': /* SD -- Scroll <n> line down */
 		DEFAULT(csiescseq.arg[0], 1);
@@ -1751,9 +1989,11 @@ csihandle(void)
 		tdeleteline(csiescseq.arg[0]);
 		break;
 	case 'X': /* ECH -- Erase <n> char */
+		if (csiescseq.arg[0] < 0)
+			return;
 		DEFAULT(csiescseq.arg[0], 1);
-		tclearregion(term.c.x, term.c.y,
-				term.c.x + csiescseq.arg[0] - 1, term.c.y);
+		x = MIN(term.c.x + csiescseq.arg[0], term.col) - 1;
+		tclearregion(term.c.x, term.c.y, x, term.c.y, 1);
 		break;
 	case 'P': /* DCH -- Delete <n> char */
 		DEFAULT(csiescseq.arg[0], 1);
@@ -1775,9 +2015,9 @@ csihandle(void)
 		break;
 	case 'n': /* DSR – Device Status Report (cursor position) */
 		if (csiescseq.arg[0] == 6) {
-			len = snprintf(buf, sizeof(buf), "\033[%i;%iR",
+			n = snprintf(buf, sizeof(buf), "\033[%i;%iR",
 					term.c.y+1, term.c.x+1);
-			ttywrite(buf, len, 0);
+			ttywrite(buf, n, 0);
 		}
 		break;
 	case 'r': /* DECSTBM -- Set Scrolling Region */
@@ -1846,21 +2086,22 @@ strhandle(void)
 	int j, narg, par;
 
 	term.esc &= ~(ESC_STR_END|ESC_STR);
-	strparse();
-	par = (narg = strescseq.narg) ? atoi(strescseq.args[0]) : 0;
+	strescseq.buf[strescseq.len] = '\0';
 
 	switch (strescseq.type) {
 	case ']': /* OSC -- Operating System Command */
+		strparse();
+		par = (narg = strescseq.narg) ? atoi(STRESCARGJUST(0)) : 0;
 		switch (par) {
 		case 0:
 		case 1:
 		case 2:
 			if (narg > 1)
-				xsettitle(strescseq.args[1]);
+				xsettitle(STRESCARGREST(1));
 			return;
 		case 52:
 			if (narg > 2 && allowwindowops) {
-				dec = base64dec(strescseq.args[2]);
+				dec = base64dec(STRESCARGREST(1));
 				if (dec) {
 					xsetsel(dec);
 					xclipcopy();
@@ -1872,10 +2113,10 @@ strhandle(void)
 		case 4: /* color set */
 			if (narg < 3)
 				break;
-			p = strescseq.args[2];
+			p = STRESCARGREST(2);
 			/* FALLTHROUGH */
 		case 104: /* color reset, here p = NULL */
-			j = (narg > 1) ? atoi(strescseq.args[1]) : -1;
+			j = (narg > 1) ? atoi(STRESCARGREST(1)) : -1;
 			if (xsetcolorname(j, p)) {
 				if (par == 104 && narg <= 1)
 					return; /* color reset without parameter */
@@ -1886,13 +2127,15 @@ strhandle(void)
 				 * TODO if defaultbg color is changed, borders
 				 * are dirty
 				 */
+				if (j == defaultbg)
+					xclearwin();
 				redraw();
 			}
 			return;
 		}
 		break;
 	case 'k': /* old title set compatibility */
-		xsettitle(strescseq.args[0]);
+		xsettitle(STRESCARGREST(0));
 		return;
 	case 'P': /* DCS -- Device Control String */
 	case '_': /* APC -- Application Program Command */
@@ -1911,18 +2154,17 @@ strparse(void)
 	char *p = strescseq.buf;
 
 	strescseq.narg = 0;
-	strescseq.buf[strescseq.len] = '\0';
 
 	if (*p == '\0')
 		return;
 
 	while (strescseq.narg < STR_ARG_SIZ) {
-		strescseq.args[strescseq.narg++] = p;
 		while ((c = *p) != ';' && c != '\0')
-			++p;
+			p++;
+		strescseq.argp[strescseq.narg++] = p;
 		if (c == '\0')
 			return;
-		*p++ = '\0';
+		p++;
 	}
 }
 
@@ -2011,16 +2253,20 @@ tdumpsel(void)
 void
 tdumpline(int n)
 {
-	char buf[UTF_SIZ];
-	Glyph *bp, *end;
+	char str[(term.col + 1) * UTF_SIZ];
+	char *ptr;
+	const Glyph *gp, *last;
 
-	bp = &term.line[n][0];
-	end = &bp[MIN(tlinelen(n), term.col) - 1];
-	if (bp != end || bp->u != ' ') {
-		for ( ; bp <= end; ++bp)
-			tprinter(buf, utf8encode(bp->u, buf));
-	}
-	tprinter("\n", 1);
+	gp = &term.line[n][0];
+	last = &gp[term.col - 1];
+	while (last > gp && last->state == GLYPH_EMPTY)
+		last--;
+
+	ptr = tgetline(str, gp, last, 1);
+	if (!(last->mode & ATTR_WRAP))
+		*(ptr++) = '\n';
+
+	tprinter(str, ptr-str);
 }
 
 void
@@ -2049,6 +2295,26 @@ tputtab(int n)
 	term.c.x = LIMIT(x, 0, term.col-1);
 }
 
+void
+twritetab(void)
+{
+	int x = term.c.x, y = term.c.y;
+
+	/* selected() takes relative coordinates */
+	if (selected(x + term.scr, y + term.scr))
+		selclear();
+
+	term.line[y][x].u = ' ';
+	term.line[y][x].state = GLYPH_TAB;
+
+	while (++x < term.col && !term.tabs[x]) {
+		term.line[y][x].u = ' ';
+		term.line[y][x].state = GLYPH_TDUMMY;
+	}
+
+	term.c.x = MIN(x, term.col-1);
+}
+
 void
 tdefutf8(char ascii)
 {
@@ -2112,7 +2378,7 @@ tcontrolcode(uchar ascii)
 {
 	switch (ascii) {
 	case '\t':   /* HT */
-		tputtab(1);
+		twritetab();
 		return;
 	case '\b':   /* BS */
 		tmoveto(term.c.x-1, term.c.y);
@@ -2241,7 +2507,7 @@ eschandle(uchar ascii)
 		return 0;
 	case 'D': /* IND -- Linefeed */
 		if (term.c.y == term.bot) {
-			tscrollup(term.top, 1);
+			tscrollup(term.top, term.bot, 1, SCROLL_SAVEHIST);
 		} else {
 			tmoveto(term.c.x, term.c.y+1);
 		}
@@ -2394,7 +2660,8 @@ check_control_code:
 		 */
 		return;
 	}
-	if (selected(term.c.x, term.c.y))
+	/* selected() takes relative coordinates */
+	if (selected(term.c.x + term.scr, term.c.y + term.scr))
 		selclear();
 
 	gp = &term.line[term.c.y][term.c.x];
@@ -2425,6 +2692,7 @@ check_control_code:
 	if (term.c.x+width < term.col) {
 		tmoveto(term.c.x+width, term.c.y);
 	} else {
+		term.wrapcwidth[IS_SET(MODE_ALTSCREEN)] = width;
 		term.c.state |= CURSOR_WRAPNEXT;
 	}
 }
@@ -2462,85 +2730,280 @@ twrite(const char *buf, int buflen, int show_ctrl)
 }
 
 void
-tresize(int col, int row)
+treflow(int col, int row)
 {
-	int i;
-	int minrow = MIN(row, term.row);
-	int mincol = MIN(col, term.col);
-	int *bp;
-	TCursor c;
-
-	if (col < 1 || row < 1) {
-		fprintf(stderr,
-		        "tresize: error resizing to %dx%d\n", col, row);
-		return;
+	int i, j;
+	int oce, nce, bot, scr;
+	int ox = 0, oy = -term.histf, nx = 0, ny = -1, len;
+	int cy = -1; /* proxy for new y coordinate of cursor */
+	int nlines;
+	Line *buf, line;
+
+	/* y coordinate of cursor line end */
+	for (oce = term.c.y; oce < term.row - 1 &&
+	                     tiswrapped(term.line[oce]); oce++);
+
+	nlines = term.histf + oce + 1;
+	if (col < term.col) {
+		/* each line can take this many lines after reflow */
+		j = (term.col + col - 1) / col;
+		nlines = j * nlines;
+		if (nlines > HISTSIZE + RESIZEBUFFER + row) {
+			nlines = HISTSIZE + RESIZEBUFFER + row;
+			oy = -(nlines / j - oce - 1);
+		}
 	}
+	buf = xmalloc(nlines * sizeof(Line));
+	do {
+		if (!nx)
+			buf[++ny] = xmalloc(col * sizeof(Glyph));
+		if (!ox) {
+			line = TLINEABS(oy);
+			len = tlinelen(line);
+		}
+		if (oy == term.c.y) {
+			if (!ox)
+				len = MAX(len, term.c.x + 1);
+			/* update cursor */
+			if (cy < 0 && term.c.x - ox < col - nx) {
+				term.c.x = nx + term.c.x - ox, cy = ny;
+				UPDATEWRAPNEXT(0, col);
+			}
+		}
+		/* get reflowed lines in buf */
+		if (col - nx > len - ox) {
+			memcpy(&buf[ny][nx], &line[ox], (len-ox) * sizeof(Glyph));
+			nx += len - ox;
+			if (len == 0 || !(line[len - 1].mode & ATTR_WRAP)) {
+				for (j = nx; j < col; j++)
+					tclearglyph(&buf[ny][j], 0);
+				nx = 0;
+			} else {
+				buf[ny][nx - 1].mode &= ~ATTR_WRAP;
+			}
+			ox = 0, oy++;
+		} else if (col - nx == len - ox) {
+			memcpy(&buf[ny][nx], &line[ox], (col-nx) * sizeof(Glyph));
+			ox = 0, oy++, nx = 0;
+		} else/* if (col - nx < len - ox) */ {
+			memcpy(&buf[ny][nx], &line[ox], (col-nx) * sizeof(Glyph));
+			for (ox += col - nx; ox < len &&
+			                     line[ox].mode == GLYPH_TDUMMY; ox++);
+			if (ox == len) {
+				ox = 0, oy++;
+			} else {
+				buf[ny][col - 1].mode |= ATTR_WRAP;
+			}
+			nx = 0;
+		}
+	} while (oy <= oce);
+	if (nx)
+		for (j = nx; j < col; j++)
+			tclearglyph(&buf[ny][j], 0);
 
-	/*
-	 * slide screen to keep cursor where we expect it -
-	 * tscrollup would work here, but we can optimize to
-	 * memmove because we're freeing the earlier lines
-	 */
-	for (i = 0; i <= term.c.y - row; i++) {
+	/* free extra lines */
+	for (i = row; i < term.row; i++)
 		free(term.line[i]);
-		free(term.alt[i]);
+	/* resize to new height */
+	term.line = xrealloc(term.line, row * sizeof(Line));
+
+	bot = MIN(ny, row - 1);
+	scr = MAX(row - term.row, 0);
+	/* update y coordinate of cursor line end */
+	nce = MIN(oce + scr, bot);
+	/* update cursor y coordinate */
+	term.c.y = nce - (ny - cy);
+	if (term.c.y < 0) {
+		j = nce, nce = MIN(nce + -term.c.y, bot);
+		term.c.y += nce - j;
+		while (term.c.y < 0) {
+			free(buf[ny--]);
+			term.c.y++;
+		}
 	}
-	/* ensure that both src and dst are not NULL */
-	if (i > 0) {
-		memmove(term.line, term.line + i, row * sizeof(Line));
-		memmove(term.alt, term.alt + i, row * sizeof(Line));
+	/* allocate new rows */
+	for (i = row - 1; i > nce; i--) {
+		term.line[i] = xmalloc(col * sizeof(Glyph));
+		for (j = 0; j < col; j++)
+			tclearglyph(&term.line[i][j], 0);
 	}
-	for (i += row; i < term.row; i++) {
+	/* fill visible area */
+	for (/*i = nce */; i >= term.row; i--, ny--)
+		term.line[i] = buf[ny];
+	for (/*i = term.row - 1 */; i >= 0; i--, ny--) {
 		free(term.line[i]);
-		free(term.alt[i]);
+		term.line[i] = buf[ny];
+	}
+	/* fill lines in history buffer and update term.histf */
+	for (/*i = -1 */; ny >= 0 && i >= -HISTSIZE; i--, ny--) {
+		j = (term.histi + i + 1 + HISTSIZE) % HISTSIZE;
+		free(term.hist[j]);
+		term.hist[j] = buf[ny];
+	}
+	term.histf = -i - 1;
+	term.scr = MIN(term.scr, term.histf);
+	/* resize rest of the history lines */
+	for (/*i = -term.histf - 1 */; i >= -HISTSIZE; i--) {
+		j = (term.histi + i + 1 + HISTSIZE) % HISTSIZE;
+		term.hist[j] = xrealloc(term.hist[j], col * sizeof(Glyph));
 	}
+	free(buf);
+}
 
-	/* resize to new height */
-	term.line = xrealloc(term.line, row * sizeof(Line));
-	term.alt  = xrealloc(term.alt,  row * sizeof(Line));
-	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
-	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
+void
+rscrolldown(int n)
+{
+	int i;
+	Line temp;
 
-	/* resize each row to new width, zero-pad if needed */
-	for (i = 0; i < minrow; i++) {
-		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
-		term.alt[i]  = xrealloc(term.alt[i],  col * sizeof(Glyph));
-	}
+	/* can never be true as of now
+	if (IS_SET(MODE_ALTSCREEN))
+		return; */
 
-	/* allocate any new rows */
-	for (/* i = minrow */; i < row; i++) {
-		term.line[i] = xmalloc(col * sizeof(Glyph));
-		term.alt[i] = xmalloc(col * sizeof(Glyph));
+	if ((n = MIN(n, term.histf)) <= 0)
+		return;
+
+	for (i = term.c.y + n; i >= n; i--) {
+		temp = term.line[i];
+		term.line[i] = term.line[i-n];
+		term.line[i-n] = temp;
+	}
+	for (/*i = n - 1 */; i >= 0; i--) {
+		temp = term.line[i];
+		term.line[i] = term.hist[term.histi];
+		term.hist[term.histi] = temp;
+		term.histi = (term.histi - 1 + HISTSIZE) % HISTSIZE;
+	}
+	term.c.y += n;
+	term.histf -= n;
+	if ((i = term.scr - n) >= 0) {
+		term.scr = i;
+	} else {
+		term.scr = 0;
+		if (sel.ob.x != -1 && !sel.alt)
+			selmove(-i);
 	}
+}
+
+void
+tresize(int col, int row)
+{
+	int *bp;
+
+	/* col and row are always MAX(_, 1)
+	if (col < 1 || row < 1) {
+		fprintf(stderr, "tresize: error resizing to %dx%d\n", col, row);
+		return;
+	} */
+
+	term.dirty = xrealloc(term.dirty, row * sizeof(*term.dirty));
+	term.tabs = xrealloc(term.tabs, col * sizeof(*term.tabs));
 	if (col > term.col) {
 		bp = term.tabs + term.col;
-
 		memset(bp, 0, sizeof(*term.tabs) * (col - term.col));
 		while (--bp > term.tabs && !*bp)
 			/* nothing */ ;
 		for (bp += tabspaces; bp < term.tabs + col; bp += tabspaces)
 			*bp = 1;
 	}
-	/* update terminal size */
-	term.col = col;
-	term.row = row;
-	/* reset scrolling region */
-	tsetscroll(0, row-1);
-	/* make use of the LIMIT in tmoveto */
-	tmoveto(term.c.x, term.c.y);
-	/* Clearing both screens (it makes dirty all lines) */
-	c = term.c;
-	for (i = 0; i < 2; i++) {
-		if (mincol < col && 0 < minrow) {
-			tclearregion(mincol, 0, col - 1, minrow - 1);
+
+	if (IS_SET(MODE_ALTSCREEN))
+		tresizealt(col, row);
+	else
+		tresizedef(col, row);
+}
+
+void
+tresizedef(int col, int row)
+{
+	int i, j;
+
+	/* return if dimensions haven't changed */
+	if (term.col == col && term.row == row) {
+		tfulldirt();
+		return;
+	}
+	if (col != term.col) {
+		if (!sel.alt)
+			selremove();
+		treflow(col, row);
+	} else {
+		/* slide screen up if otherwise cursor would get out of the screen */
+		if (term.c.y >= row) {
+			tscrollup(0, term.row - 1, term.c.y - row + 1, SCROLL_RESIZE);
+			term.c.y = row - 1;
 		}
-		if (0 < col && minrow < row) {
-			tclearregion(0, minrow, col - 1, row - 1);
+		for (i = row; i < term.row; i++)
+			free(term.line[i]);
+
+		/* resize to new height */
+		term.line = xrealloc(term.line, row * sizeof(Line));
+		/* allocate any new rows */
+		for (i = term.row; i < row; i++) {
+			term.line[i] = xmalloc(col * sizeof(Glyph));
+			for (j = 0; j < col; j++)
+				tclearglyph(&term.line[i][j], 0);
 		}
-		tswapscreen();
-		tcursor(CURSOR_LOAD);
+		/* scroll down as much as height has increased */
+		rscrolldown(row - term.row);
+	}
+	/* update terminal size */
+	term.col = col, term.row = row;
+	/* reset scrolling region */
+	term.top = 0, term.bot = row - 1;
+	/* dirty all lines */
+	tfulldirt();
+}
+
+void
+tresizealt(int col, int row)
+{
+	int i, j;
+
+	/* return if dimensions haven't changed */
+	if (term.col == col && term.row == row) {
+		tfulldirt();
+		return;
+	}
+	if (sel.alt)
+		selremove();
+	/* slide screen up if otherwise cursor would get out of the screen */
+	for (i = 0; i <= term.c.y - row; i++)
+		free(term.line[i]);
+	if (i > 0) {
+		/* ensure that both src and dst are not NULL */
+		memmove(term.line, term.line + i, row * sizeof(Line));
+		term.c.y = row - 1;
+	}
+	for (i += row; i < term.row; i++)
+		free(term.line[i]);
+	/* resize to new height */
+	term.line = xrealloc(term.line, row * sizeof(Line));
+	/* resize to new width */
+	for (i = 0; i < MIN(row, term.row); i++) {
+		term.line[i] = xrealloc(term.line[i], col * sizeof(Glyph));
+		for (j = term.col; j < col; j++)
+			tclearglyph(&term.line[i][j], 0);
 	}
-	term.c = c;
+	/* allocate any new rows */
+	for (/*i = MIN(row, term.row) */; i < row; i++) {
+		term.line[i] = xmalloc(col * sizeof(Glyph));
+		for (j = 0; j < col; j++)
+			tclearglyph(&term.line[i][j], 0);
+	}
+	/* update cursor */
+	if (term.c.x >= col) {
+		term.c.state &= ~CURSOR_WRAPNEXT;
+		term.c.x = col - 1;
+	} else {
+		UPDATEWRAPNEXT(1, col);
+	}
+	/* update terminal size */
+	term.col = col, term.row = row;
+	/* reset scrolling region */
+	term.top = 0, term.bot = row - 1;
+	/* dirty all lines */
+	tfulldirt();
 }
 
 void
@@ -2559,7 +3022,7 @@ drawregion(int x1, int y1, int x2, int y2)
 			continue;
 
 		term.dirty[y] = 0;
-		xdrawline(term.line[y], x1, y, x2);
+		xdrawline(TLINE(y), x1, y, x2);
 	}
 }
 
@@ -2580,7 +3043,7 @@ draw(void)
 		cx--;
 
 	drawregion(0, 0, term.col, term.row);
-	xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
+    if(!term.scr) xdrawcursor(cx, term.c.y, term.line[term.c.y][cx],
 			term.ocx, term.ocy, term.line[term.ocy][term.ocx]);
 	term.ocx = cx;
 	term.ocy = term.c.y;
diff --git a/st.h b/st.h
index 3d351b6..a295495 100644
--- a/st.h
+++ b/st.h
@@ -33,9 +33,17 @@ enum glyph_attribute {
 	ATTR_WRAP       = 1 << 8,
 	ATTR_WIDE       = 1 << 9,
 	ATTR_WDUMMY     = 1 << 10,
+	ATTR_SELECTED   = 1 << 13,
 	ATTR_BOLD_FAINT = ATTR_BOLD | ATTR_FAINT,
 };
 
+enum glyph_state {
+	GLYPH_EMPTY,
+	GLYPH_SET,
+	GLYPH_TAB,
+	GLYPH_TDUMMY
+};
+
 enum selection_mode {
 	SEL_IDLE = 0,
 	SEL_EMPTY = 1,
@@ -63,6 +71,7 @@ typedef uint_least32_t Rune;
 typedef struct {
 	Rune u;           /* character code */
 	ushort mode;      /* attribute flags */
+  ushort state;     /* state flags */
 	uint32_t fg;      /* foreground  */
 	uint32_t bg;      /* background  */
 } Glyph;
@@ -77,10 +86,17 @@ typedef union {
 	const char *s;
 } Arg;
 
+/*typedef struct {
+	const int histlines;
+	char *const *cmd;
+} ExternalPipe;*/
+
 void die(const char *, ...);
 void redraw(void);
 void draw(void);
 
+void kscrolldown(const Arg *);
+void kscrollup(const Arg *);
 void printscreen(const Arg *);
 void printsel(const Arg *);
 void sendbreak(const Arg *);
@@ -88,6 +104,7 @@ void toggleprinter(const Arg *);
 
 int tattrset(int);
 void tnew(int, int);
+int tisaltscreen(void);
 void tresize(int, int);
 void tsetdirtattr(int);
 void ttyhangup(void);
@@ -111,6 +128,7 @@ void *xmalloc(size_t);
 void *xrealloc(void *, size_t);
 char *xstrdup(char *);
 
+
 /* config.h globals */
 extern char *utmp;
 extern char *scroll;
diff --git a/win.h b/win.h
index a6ef1b9..d7b4980 100644
--- a/win.h
+++ b/win.h
@@ -37,3 +37,4 @@ void xsetpointermotion(int);
 void xsetsel(char *);
 int xstartdraw(void);
 void xximspot(int, int);
+void xclearwin(void);
diff --git a/x.c b/x.c
index 210f184..e516b9d 100644
--- a/x.c
+++ b/x.c
@@ -34,6 +34,7 @@ typedef struct {
 	void (*func)(const Arg *);
 	const Arg arg;
 	uint  release;
+  int altscreen;
 } MouseShortcut;
 
 typedef struct {
@@ -63,6 +64,9 @@ static void ttysend(const Arg *);
 /* config.h for applying patches and the configuration. */
 #include "config.h"
 
+/* Calculate count of spare fonts */
+int fc;
+
 /* XEMBED messages */
 #define XEMBED_FOCUS_IN  4
 #define XEMBED_FOCUS_OUT 5
@@ -81,8 +85,10 @@ typedef XftGlyphFontSpec GlyphFontSpec;
 typedef struct {
 	int tw, th; /* tty width and height */
 	int w, h; /* window width and height */
+	int hborderpx, vborderpx;
 	int ch; /* char height */
 	int cw; /* char width  */
+	int cyo; /* char y offset */
 	int mode; /* window state/mode flags */
 	int cursor; /* cursor style */
 } TermWindow;
@@ -93,7 +99,7 @@ typedef struct {
 	Window win;
 	Drawable buf;
 	GlyphFontSpec *specbuf; /* font spec buffer used for rendering */
-	Atom xembed, wmdeletewin, netwmname, netwmpid;
+	Atom xembed, wmdeletewin, netwmname, netwmiconname, netwmpid;
 	struct {
 		XIM xim;
 		XIC xic;
@@ -331,7 +337,7 @@ ttysend(const Arg *arg)
 int
 evcol(XEvent *e)
 {
-	int x = e->xbutton.x - borderpx;
+	int x = e->xbutton.x - win.hborderpx;
 	LIMIT(x, 0, win.tw - 1);
 	return x / win.cw;
 }
@@ -339,7 +345,7 @@ evcol(XEvent *e)
 int
 evrow(XEvent *e)
 {
-	int y = e->xbutton.y - borderpx;
+  int y = e->xbutton.y - win.vborderpx;
 	LIMIT(y, 0, win.th - 1);
 	return y / win.ch;
 }
@@ -387,7 +393,9 @@ mousereport(XEvent *e)
 			button = 3;
 		} else {
 			button -= Button1;
-			if (button >= 3)
+			if (button >= 7)
+				button += 128 - 7;
+			else if (button >= 3)
 				button += 64 - 3;
 		}
 		if (e->xbutton.type == ButtonPress) {
@@ -446,6 +454,7 @@ mouseaction(XEvent *e, uint release)
 	for (ms = mshortcuts; ms < mshortcuts + LEN(mshortcuts); ms++) {
 		if (ms->release == release &&
 		    ms->button == e->xbutton.button &&
+        (!ms->altscreen || ms->altscreen == (tisaltscreen() ? 1 : -1)) &&
 		    (match(ms->mod, state) ||  /* exact or forced */
 		     match(ms->mod, state & ~forcemousemod))) {
 			ms->func(&(ms->arg));
@@ -673,6 +682,7 @@ setsel(char *str, Time t)
 	XSetSelectionOwner(xw.dpy, XA_PRIMARY, xw.win, t);
 	if (XGetSelectionOwner(xw.dpy, XA_PRIMARY) != xw.win)
 		selclear();
+  clipcopy(NULL);
 }
 
 void
@@ -721,6 +731,9 @@ cresize(int width, int height)
 	col = MAX(1, col);
 	row = MAX(1, row);
 
+	win.hborderpx = (win.w - col * win.cw) / 2;
+	win.vborderpx = (win.h - row * win.ch) / 2;
+
 	tresize(col, row);
 	xresize(col, row);
 	ttyresize(win.tw, win.th);
@@ -772,6 +785,16 @@ xloadcolor(int i, const char *name, Color *ncolor)
 	return XftColorAllocName(xw.dpy, xw.vis, xw.cmap, name, ncolor);
 }
 
+/*void
+xloadalpha(void)
+{
+	float const usedAlpha = focused ? alpha : alphaUnfocused;
+	if (opt_alpha) alpha = strtof(opt_alpha, NULL);
+	dc.col[defaultbg].color.alpha = (unsigned short)(0xffff * usedAlpha);
+	dc.col[defaultbg].pixel &= 0x00FFFFFF;
+	dc.col[defaultbg].pixel |= (unsigned char)(0xff * usedAlpha) << 24;
+}*/
+
 void
 xloadcols(void)
 {
@@ -825,6 +848,13 @@ xclear(int x1, int y1, int x2, int y2)
 			x1, y1, x2-x1, y2-y1);
 }
 
+void
+xclearwin(void)
+{
+	xclear(0, 0, win.w, win.h);
+}
+
+
 void
 xhints(void)
 {
@@ -838,8 +868,8 @@ xhints(void)
 	sizeh->flags = PSize | PResizeInc | PBaseSize | PMinSize;
 	sizeh->height = win.h;
 	sizeh->width = win.w;
-	sizeh->height_inc = win.ch;
-	sizeh->width_inc = win.cw;
+	sizeh->height_inc = 1;
+	sizeh->width_inc = 1;
 	sizeh->base_height = 2 * borderpx;
 	sizeh->base_width = 2 * borderpx;
 	sizeh->min_height = win.ch + 2 * borderpx;
@@ -1000,6 +1030,7 @@ xloadfonts(char *fontstr, double fontsize)
 	/* Setting character width and height. */
 	win.cw = ceilf(dc.font.width * cwscale);
 	win.ch = ceilf(dc.font.height * chscale);
+	win.cyo = ceilf(dc.font.height * (chscale - 1) / 2);
 
 	FcPatternDel(pattern, FC_SLANT);
 	FcPatternAddInteger(pattern, FC_SLANT, FC_SLANT_ITALIC);
@@ -1116,6 +1147,8 @@ xinit(int cols, int rows)
 	usedfont = (opt_font == NULL)? font : opt_font;
 	xloadfonts(usedfont, 0);
 
+	/* spare fonts */
+
 	/* colors */
 	xw.cmap = XDefaultColormap(xw.dpy, xw.scr);
 	xloadcols();
@@ -1186,6 +1219,7 @@ xinit(int cols, int rows)
 	xw.xembed = XInternAtom(xw.dpy, "_XEMBED", False);
 	xw.wmdeletewin = XInternAtom(xw.dpy, "WM_DELETE_WINDOW", False);
 	xw.netwmname = XInternAtom(xw.dpy, "_NET_WM_NAME", False);
+	xw.netwmiconname = XInternAtom(xw.dpy, "_NET_WM_ICON_NAME", False);
 	XSetWMProtocols(xw.dpy, xw.win, &xw.wmdeletewin, 1);
 
 	xw.netwmpid = XInternAtom(xw.dpy, "_NET_WM_PID", False);
@@ -1210,7 +1244,7 @@ xinit(int cols, int rows)
 int
 xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x, int y)
 {
-	float winx = borderpx + x * win.cw, winy = borderpx + y * win.ch, xp, yp;
+	float winx = win.hborderpx + x * win.cw, winy = win.vborderpx + y * win.ch, xp, yp;
 	ushort mode, prevmode = USHRT_MAX;
 	Font *font = &dc.font;
 	int frcflags = FRC_NORMAL;
@@ -1223,7 +1257,7 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
 	FcCharSet *fccharset;
 	int i, f, numspecs = 0;
 
-	for (i = 0, xp = winx, yp = winy + font->ascent; i < len; ++i) {
+	for (i = 0, xp = winx, yp = winy + font->ascent + win.cyo; i < len; ++i) {
 		/* Fetch rune and mode for current glyph. */
 		rune = glyphs[i].u;
 		mode = glyphs[i].mode;
@@ -1248,7 +1282,7 @@ xmakeglyphfontspecs(XftGlyphFontSpec *specs, const Glyph *glyphs, int len, int x
 				font = &dc.bfont;
 				frcflags = FRC_BOLD;
 			}
-			yp = winy + font->ascent;
+  			yp = winy + font->ascent + win.cyo;
 		}
 
 		/* Lookup character index with default font. */
@@ -1343,7 +1377,7 @@ void
 xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, int y)
 {
 	int charlen = len * ((base.mode & ATTR_WIDE) ? 2 : 1);
-	int winx = borderpx + x * win.cw, winy = borderpx + y * win.ch,
+	int winx = win.hborderpx + x * win.cw, winy = win.vborderpx + y * win.ch,
 	    width = charlen * win.cw;
 	Color *fg, *bg, *temp, revfg, revbg, truefg, truebg;
 	XRenderColor colfg, colbg;
@@ -1433,17 +1467,17 @@ xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, i
 
 	/* Intelligent cleaning up of the borders. */
 	if (x == 0) {
-		xclear(0, (y == 0)? 0 : winy, borderpx,
+		xclear(0, (y == 0)? 0 : winy, win.vborderpx,
 			winy + win.ch +
-			((winy + win.ch >= borderpx + win.th)? win.h : 0));
+			((winy + win.ch >= win.hborderpx + win.th)? win.h : 0));
 	}
-	if (winx + width >= borderpx + win.tw) {
+	if (winx + width >= win.hborderpx + win.tw) {
 		xclear(winx + width, (y == 0)? 0 : winy, win.w,
-			((winy + win.ch >= borderpx + win.th)? win.h : (winy + win.ch)));
+			((winy + win.ch >= win.vborderpx + win.th)? win.h : (winy + win.ch)));
 	}
 	if (y == 0)
 		xclear(winx, 0, winx + width, borderpx);
-	if (winy + win.ch >= borderpx + win.th)
+	if (winy + win.ch >= win.vborderpx + win.th)
 		xclear(winx, winy + win.ch, winx + width, win.h);
 
 	/* Clean up the region we want to draw to. */
@@ -1466,7 +1500,7 @@ xdrawglyphfontspecs(const XftGlyphFontSpec *specs, Glyph base, int len, int x, i
 	}
 
 	if (base.mode & ATTR_STRUCK) {
-		XftDrawRect(xw.draw, fg, winx, winy + 2 * dc.font.ascent / 3,
+		XftDrawRect(xw.draw, fg, winx, winy + win.cyo + 2 * dc.font.ascent / 3,
 				width, 1);
 	}
 
@@ -1488,6 +1522,7 @@ void
 xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
 {
 	Color drawcol;
+	XRenderColor colbg;
 
 	/* remove the old cursor */
 	if (selected(ox, oy))
@@ -1517,10 +1552,23 @@ xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
 			g.fg = defaultfg;
 			g.bg = defaultrcs;
 		} else {
+			/** this is the main part of the dynamic cursor color patch */
+			g.bg = g.fg;
 			g.fg = defaultbg;
-			g.bg = defaultcs;
 		}
-		drawcol = dc.col[g.bg];
+		/*
+		 * and this is the second part of the dynamic cursor color patch.
+		 * it handles the `drawcol` variable
+		*/
+		if (IS_TRUECOL(g.bg)) {
+			colbg.alpha = 0xffff;
+			colbg.red = TRUERED(g.bg);
+			colbg.green = TRUEGREEN(g.bg);
+			colbg.blue = TRUEBLUE(g.bg);
+			XftColorAllocValue(xw.dpy, xw.vis, xw.cmap, &colbg, &drawcol);
+		} else {
+			drawcol = dc.col[g.bg];
+		}
 	}
 
 	/* draw the new one */
@@ -1537,35 +1585,35 @@ xdrawcursor(int cx, int cy, Glyph g, int ox, int oy, Glyph og)
 		case 3: /* Blinking Underline */
 		case 4: /* Steady Underline */
 			XftDrawRect(xw.draw, &drawcol,
-					borderpx + cx * win.cw,
-					borderpx + (cy + 1) * win.ch - \
+					win.hborderpx + cx * win.cw,
+					win.vborderpx + (cy + 1) * win.ch - \
 						cursorthickness,
 					win.cw, cursorthickness);
 			break;
 		case 5: /* Blinking bar */
 		case 6: /* Steady bar */
 			XftDrawRect(xw.draw, &drawcol,
-					borderpx + cx * win.cw,
-					borderpx + cy * win.ch,
+					win.hborderpx + cx * win.cw,
+					win.vborderpx + cy * win.ch,
 					cursorthickness, win.ch);
 			break;
 		}
 	} else {
 		XftDrawRect(xw.draw, &drawcol,
-				borderpx + cx * win.cw,
-				borderpx + cy * win.ch,
+				win.hborderpx + cx * win.cw,
+				win.vborderpx + cy * win.ch,
 				win.cw - 1, 1);
 		XftDrawRect(xw.draw, &drawcol,
-				borderpx + cx * win.cw,
-				borderpx + cy * win.ch,
+				win.hborderpx + cx * win.cw,
+				win.vborderpx + cy * win.ch,
 				1, win.ch - 1);
 		XftDrawRect(xw.draw, &drawcol,
-				borderpx + (cx + 1) * win.cw - 1,
-				borderpx + cy * win.ch,
+				win.hborderpx + (cx + 1) * win.cw - 1,
+				win.vborderpx + cy * win.ch,
 				1, win.ch - 1);
 		XftDrawRect(xw.draw, &drawcol,
-				borderpx + cx * win.cw,
-				borderpx + (cy + 1) * win.ch - 1,
+				win.hborderpx + cx * win.cw,
+				win.vborderpx + (cy + 1) * win.ch - 1,
 				win.cw, 1);
 	}
 }
@@ -1579,6 +1627,7 @@ xsetenv(void)
 	setenv("WINDOWID", buf, 1);
 }
 
+
 void
 xsettitle(char *p)
 {
-- 
2.33.1

